# Guia para Adicionar Novas Funcionalidades

Este documento fornece um guia detalhado sobre como adicionar novas funcionalidades ao Sistema de Análise de FIIs, desde o planejamento até a implementação e documentação.

## Processo de Desenvolvimento de Novas Funcionalidades

### 1. Definição e Planejamento

#### 1.1 Definir o Escopo
- Descreva claramente o que a nova funcionalidade deve fazer
- Estabeleça os limites do que está incluído e excluído
- Identifique os requisitos funcionais e não-funcionais

#### 1.2 Análise de Impacto
- Identifique quais componentes existentes serão afetados
- Avalie a necessidade de mudanças no esquema do banco de dados
- Considere o impacto em interfaces existentes (CLI, APIs)

#### 1.3 Planejamento da Implementação
- Crie um diagrama ou esboço da solução
- Identifique novos módulos/classes a serem criados
- Planeje como a funcionalidade se integrará aos componentes existentes

### 2. Implementação Incremental

#### 2.1 Desenvolvimento Inicial
- Comece com os componentes fundamentais (modelo de dados, lógica core)
- Implemente primeiro as partes independentes
- Crie testes para validar o comportamento esperado

#### 2.2 Integração
- Conecte a nova funcionalidade aos componentes existentes
- Adapte interfaces conforme necessário
- Verifique se a integração preserva o comportamento existente

#### 2.3 Refinamento
- Otimize o código para desempenho e legibilidade
- Implemente tratamento de erros adequado
- Revise a solução para garantir aderência aos padrões

### 3. Testes

#### 3.1 Testes Unitários
- Teste cada componente individualmente
- Verifique casos de borda e condições de erro
- Garanta cobertura adequada de código

#### 3.2 Testes de Integração
- Teste a interação com outros componentes
- Verifique comportamento em cenários reais
- Teste a interface do usuário (CLI)

#### 3.3 Validação
- Confirme que a funcionalidade atende aos requisitos
- Verifique o comportamento com dados reais
- Teste de performance para grandes volumes de dados

### 4. Documentação

#### 4.1 Documentação de Código
- Adicione docstrings completas para classes e métodos
- Explique aspectos não-óbvios da implementação
- Documente pré-condições e pós-condições

#### 4.2 Documentação do Usuário
- Atualize o README com a nova funcionalidade
- Adicione exemplos de uso
- Explique parâmetros e configurações

#### 4.3 Documentação do Desenvolvedor
- Atualize este guia de desenvolvimento se necessário
- Documente decisões de design importantes
- Explique como estender a nova funcionalidade

## Integração com Componentes Existentes

### Interface de Linha de Comando

Para adicionar comandos à interface unificada (`main.py`), siga estas etapas:

1. **Adicione um novo subparser** para o comando:

```python
# Em main.py, na seção de configuração de argumentos
parser_novocomando = subparsers.add_parser('novocomando', 
                                          help='Descrição do novo comando')
parser_novocomando.add_argument('--parametro', type=str, 
                              help='Descrição do parâmetro')
```

2. **Implemente a função de manipulação** do comando:

```python
def executar_novo_comando(args, logger) -> None:
    """
    Executa o novo comando.
    
    Args:
        args: Argumentos da linha de comando
        logger: Logger para registro de eventos
    """
    # Implementação do comando
    imprimir_titulo("Título do Novo Comando")
    
    # Lógica principal
    # ...
    
    imprimir_sucesso("Operação concluída com sucesso")
```

3. **Adicione o comando ao dispatcher** principal:

```python
# Em main.py, na função main()
# ...
elif args.operacao == 'novocomando':
    executar_novo_comando(args, logger)
# ...
```

### Gerenciadores de Banco de Dados

Para integrar com gerenciadores existentes, considere:

1. **Injeção de dependência**: Passe instâncias dos gerenciadores necessários para sua nova classe
2. **Herança**: Estenda um gerenciador existente apenas quando apropriado (sua classe é uma especialização)
3. **Composição**: Prefira composição sobre herança sempre que possível

Exemplo de composição:

```python
class NovaFuncionalidade:
    """
    Nova funcionalidade que utiliza gerenciadores existentes.
    """
    
    def __init__(self, arquivo_db: str = 'fundos_imobiliarios.db'):
        self.arquivo_db = arquivo_db
        self.logger = get_logger('FIIDatabase')
        
        # Composição com gerenciadores existentes
        self.cotacoes_manager = CotacoesManager(arquivo_db)
        self.eventos_manager = EventosCorporativosManager(arquivo_db)
    
    def inicializar(self) -> None:
        """
        Inicializa os gerenciadores necessários.
        """
        self.cotacoes_manager.conectar()
        self.eventos_manager.conectar()
    
    def processar(self, parametros: Dict) -> Dict:
        """
        Processa os dados usando os gerenciadores existentes.
        
        Args:
            parametros: Parâmetros de processamento
            
        Returns:
            Resultados do processamento
        """
        # Usa os gerenciadores existentes
        cotacoes = self.cotacoes_manager.obter_cotacoes(...)
        eventos = self.eventos_manager.listar_eventos(...)
        
        # Implementa a nova lógica
        resultado = self._processar_dados(cotacoes, eventos, parametros)
        
        return resultado
    
    def _processar_dados(self, cotacoes, eventos, parametros) -> Dict:
        """
        Implementa a lógica específica da nova funcionalidade.
        """
        # Implementação
        pass
    
    def fechar(self) -> None:
        """
        Fecha conexões dos gerenciadores.
        """
        self.cotacoes_manager.fechar_conexao()
        self.eventos_manager.fechar_conexao()
```

### Loggers e Configuração

Utilize os gerenciadores centralizados para logging e configuração:

```python
from fii_utils.logging_manager import get_logger
from fii_utils.config_manager import get_config_manager

class NovaFuncionalidade:
    def __init__(self):
        # Obter logger específico para este componente
        self.logger = get_logger('nova_funcionalidade')
        
        # Obter configurações
        self.config_manager = get_config_manager()
        self.parametro = self.config_manager.get("novo_parametro", "valor_padrao")
        
    def executar(self):
        self.logger.info("Iniciando nova funcionalidade")
        # Implementação
        self.logger.debug(f"Usando parâmetro: {self.parametro}")
```

## Exemplos Práticos

### Exemplo 1: Funcionalidade de Relatório de Desempenho

Neste exemplo, criaremos uma nova funcionalidade que gera relatórios de desempenho dos FIIs.

#### 1. Definição e Escopo

**Objetivo**: Gerar relatórios automáticos de desempenho dos FIIs, comparando com benchmarks e analisando tendências.

**Componentes necessários**:
- Classe `RelatorioDesempenhoManager` para gerenciar a geração de relatórios
- Integração com `CotacoesManager` para obter dados históricos
- Integração com `EventosCorporativosManager` para ajustes de preços
- Novo comando CLI para geração de relatórios

#### 2. Implementação

##### 2.1 Criar a Classe Principal

```python
# fii_utils/relatorio_desempenho.py
import os
import pandas as pd
import matplotlib.pyplot as plt
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta

from fii_utils.logging_manager import get_logger
from fii_utils.config_manager import get_config_manager
from db_managers.cotacoes import CotacoesManager
from db_managers.eventos import EventosCorporativosManager

class RelatorioDesempenhoManager:
    """
    Gerencia a geração de relatórios de desempenho para FIIs.
    Analisa dados históricos e compara com benchmarks.
    """
    
    def __init__(self, arquivo_db: str = 'fundos_imobiliarios.db'):
        self.arquivo_db = arquivo_db
        self.logger = get_logger('FIIRelatorio')
        self.config = get_config_manager()
        
        # Diretório para salvar relatórios
        self.relatorios_dir = self.config.get("relatorios_dir", "relatorios")
        os.makedirs(self.relatorios_dir, exist_ok=True)
        
        # Gerenciadores de dependências
        self.cotacoes_manager = CotacoesManager(arquivo_db)
        self.eventos_manager = EventosCorporativosManager(arquivo_db)
    
    def inicializar(self) -> None:
        """
        Inicializa os gerenciadores necessários.
        """
        self.cotacoes_manager.conectar()
        self.eventos_manager.conectar()
    
    def gerar_relatorio(self, codigo: str, data_inicio: str, data_fim: str,
                       benchmark: Optional[str] = None) -> str:
        """
        Gera relatório de desempenho para um FII específico.
        
        Args:
            codigo: Código do FII
            data_inicio: Data inicial (YYYY-MM-DD)
            data_fim: Data final (YYYY-MM-DD)
            benchmark: Código do FII ou índice de referência
            
        Returns:
            Caminho para o arquivo do relatório gerado
        """
        try:
            self.logger.info(f"Gerando relatório para {codigo} de {data_inicio} a {data_fim}")
            
            # Verificar se os gerenciadores estão conectados
            if not self.cotacoes_manager.conn:
                self.inicializar()
            
            # Obter dados de cotações do FII
            df_fii = self._obter_dados_cotacoes(codigo, data_inicio, data_fim)
            
            if df_fii.empty:
                raise ValueError(f"Não há dados disponíveis para {codigo} no período especificado")
            
            # Obter dados do benchmark se especificado
            df_benchmark = None
            if benchmark:
                df_benchmark = self._obter_dados_cotacoes(benchmark, data_inicio, data_fim)
            
            # Analisar desempenho
            analise = self._analisar_desempenho(df_fii, df_benchmark)
            
            # Gerar gráficos
            graficos = self._gerar_graficos(codigo, df_fii, df_benchmark, benchmark)
            
            # Criar relatório
            nome_arquivo = f"relatorio_{codigo}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
            caminho_relatorio = os.path.join(self.relatorios_dir, nome_arquivo)
            
            self._gerar_html_relatorio(caminho_relatorio, codigo, analise, graficos,
                                      data_inicio, data_fim, benchmark)
            
            self.logger.info(f"Relatório gerado com sucesso: {caminho_relatorio}")
            return caminho_relatorio
            
        except Exception as e:
            self.logger.error(f"Erro ao gerar relatório para {codigo}: {e}")
            raise
    
    def _obter_dados_cotacoes(self, codigo: str, data_inicio: str, data_fim: str) -> pd.DataFrame:
        """
        Obtém dados de cotações para um FII ou índice.
        
        Args:
            codigo: Código do FII ou índice
            data_inicio: Data inicial
            data_fim: Data final
            
        Returns:
            DataFrame com os dados de cotações
        """
        # Verifica se é um índice especial (ex: IFIX)
        if codigo.upper() == "IFIX":
            # Implementar lógica para obter dados do índice IFIX
            # Aqui seria necessário uma fonte adicional de dados
            # Para simplificar, retornamos um DataFrame vazio no exemplo
            return pd.DataFrame()
        
        # Para FIIs, consulta o banco de dados
        self.cotacoes_manager.cursor.execute('''
        SELECT data, abertura, maxima, minima, fechamento, volume
        FROM cotacoes
        WHERE codigo = ? AND data BETWEEN ? AND ?
        ORDER BY data
        ''', (codigo.upper(), data_inicio, data_fim))
        
        rows = self.cotacoes_manager.cursor.fetchall()
        
        if not rows:
            return pd.DataFrame()
            
        # Convertendo para DataFrame
        df = pd.DataFrame(rows, columns=['data', 'abertura', 'maxima', 'minima', 'fechamento', 'volume'])
        df['data'] = pd.to_datetime(df['data'])
        df.set_index('data', inplace=True)
        
        # Verificar eventos corporativos e ajustar preços se necessário
        eventos = self.eventos_manager.listar_eventos(codigo)
        
        if eventos and self.config.get("ajustar_precos_relatorios", True):
            df = self._ajustar_precos_eventos(df, eventos)
        
        return df
    
    def _ajustar_precos_eventos(self, df: pd.DataFrame, eventos: List[Dict]) -> pd.DataFrame:
        """
        Ajusta preços históricos com base em eventos corporativos.
        
        Args:
            df: DataFrame com cotações
            eventos: Lista de eventos corporativos
            
        Returns:
            DataFrame com preços ajustados
        """
        # Implementação simplificada do ajuste de preços
        # Na prática, essa lógica seria mais complexa
        df_ajustado = df.copy()
        
        for evento in eventos:
            data_evento = pd.to_datetime(evento['data'])
            fator = evento['fator']
            tipo = evento['evento']
            
            # Determinar multiplicador baseado no tipo de evento
            multiplicador = fator if tipo == 'grupamento' else (1.0 / fator)
            
            # Aplicar ajuste para datas anteriores ao evento
            mask = df_ajustado.index < data_evento
            
            if tipo in ['grupamento', 'desdobramento']:
                colunas_preco = ['abertura', 'maxima', 'minima', 'fechamento']
                
                for col in colunas_preco:
                    if col in df_ajustado.columns:
                        df_ajustado.loc[mask, col] = df_ajustado.loc[mask, col] * multiplicador
        
        return df_ajustado
    
    def _analisar_desempenho(self, df_fii: pd.DataFrame, 
                           df_benchmark: Optional[pd.DataFrame] = None) -> Dict:
        """
        Analisa o desempenho do FII e compara com benchmark se disponível.
        
        Args:
            df_fii: DataFrame com cotações do FII
            df_benchmark: DataFrame com cotações do benchmark (opcional)
            
        Returns:
            Dicionário com métricas de desempenho
        """
        # Estatísticas básicas
        fechamento_inicial = df_fii['fechamento'].iloc[0]
        fechamento_final = df_fii['fechamento'].iloc[-1]
        retorno_periodo = (fechamento_final / fechamento_inicial - 1) * 100
        
        retorno_anualizado = self._calcular_retorno_anualizado(
            fechamento_inicial, fechamento_final, df_fii.index[0], df_fii.index[-1]
        )
        
        volatilidade = df_fii['fechamento'].pct_change().std() * (252 ** 0.5) * 100  # Anualizada
        
        # Estatísticas de preço
        preco_maximo = df_fii['fechamento'].max()
        preco_minimo = df_fii['fechamento'].min()
        data_maximo = df_fii['fechamento'].idxmax().strftime('%Y-%m-%d')
        data_minimo = df_fii['fechamento'].idxmin().strftime('%Y-%m-%d')
        
        # Média móveis
        mm50 = df_fii['fechamento'].rolling(window=50).mean().iloc[-1]
        mm200 = df_fii['fechamento'].rolling(window=200).mean().iloc[-1]
        
        # Tendência atual (última cotação em relação às MMs)
        tendencia = "Neutro"
        if fechamento_final > mm50 > mm200:
            tendencia = "Alta"
        elif fechamento_final < mm50 < mm200:
            tendencia = "Baixa"
        
        # Comparação com benchmark
        benchmark_stats = {}
        if df_benchmark is not None and not df_benchmark.empty:
            # Alinha as datas
            datas_comuns = df_fii.index.intersection(df_benchmark.index)
            
            if len(datas_comuns) > 0:
                df_fii_comum = df_fii.loc[datas_comuns]
                df_benchmark_comum = df_benchmark.loc[datas_comuns]
                
                # Normaliza para base 100
                df_fii_norm = df_fii_comum['fechamento'] / df_fii_comum['fechamento'].iloc[0] * 100
                df_bench_norm = df_benchmark_comum['fechamento'] / df_benchmark_comum['fechamento'].iloc[0] * 100
                
                # Calcula correlação
                correlacao = df_fii_norm.corr(df_bench_norm)
                
                # Retorno relativo
                retorno_benchmark = (df_bench_norm.iloc[-1] / df_bench_norm.iloc[0] - 1) * 100
                retorno_relativo = retorno_periodo - retorno_benchmark
                
                benchmark_stats = {
                    'correlacao': correlacao,
                    'retorno_benchmark': retorno_benchmark,
                    'retorno_relativo': retorno_relativo,
                    'outperformance': retorno_relativo > 0
                }
        
        # Resultados
        resultado = {
            'retorno_periodo': retorno_periodo,
            'retorno_anualizado': retorno_anualizado,
            'volatilidade': volatilidade,
            'preco_maximo': preco_maximo,
            'preco_minimo': preco_minimo,
            'data_maximo': data_maximo,
            'data_minimo': data_minimo,
            'mm50': mm50,
            'mm200': mm200,
            'tendencia': tendencia,
            'benchmark': benchmark_stats
        }
        
        return resultado
    
    def _calcular_retorno_anualizado(self, valor_inicial: float, valor_final: float,
                                   data_inicial: pd.Timestamp, data_final: pd.Timestamp) -> float:
        """
        Calcula o retorno anualizado entre duas datas.
        
        Args:
            valor_inicial: Valor no início do período
            valor_final: Valor no fim do período
            data_inicial: Data inicial
            data_final: Data final
            
        Returns:
            Retorno anualizado em percentual
        """
        # Dias no período
        dias = (data_final - data_inicial).days
        
        # Retorno anualizado
        if dias <= 0 or valor_inicial <= 0:
            return 0.0
            
        retorno_periodo = valor_final / valor_inicial
        retorno_anualizado = (retorno_periodo ** (365.0 / dias) - 1) * 100
        
        return retorno_anualizado
    
    def _gerar_graficos(self, codigo: str, df_fii: pd.DataFrame, 
                       df_benchmark: Optional[pd.DataFrame] = None,
                       benchmark: Optional[str] = None) -> Dict:
        """
        Gera gráficos para o relatório.
        
        Args:
            codigo: Código do FII
            df_fii: DataFrame com cotações do FII
            df_benchmark: DataFrame com cotações do benchmark
            benchmark: Código do benchmark
            
        Returns:
            Dicionário com caminhos para os gráficos gerados
        """
        # Cria diretório para gráficos
        graficos_dir = os.path.join(self.relatorios_dir, 'graficos')
        os.makedirs(graficos_dir, exist_ok=True)
        
        # Nome base para os arquivos
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        base_filename = f"{codigo}_{timestamp}"
        
        # Gráfico de preço
        preco_path = os.path.join(graficos_dir, f"{base_filename}_preco.png")
        self._gerar_grafico_preco(df_fii, preco_path, codigo)
        
        # Gráfico de comparação com benchmark
        benchmark_path = None
        if df_benchmark is not None and not df_benchmark.empty and benchmark:
            benchmark_path = os.path.join(graficos_dir, f"{base_filename}_benchmark.png")
            self._gerar_grafico_benchmark(df_fii, df_benchmark, benchmark_path, codigo, benchmark)
        
        # Gráfico de volume
        volume_path = os.path.join(graficos_dir, f"{base_filename}_volume.png")
        self._gerar_grafico_volume(df_fii, volume_path, codigo)
        
        return {
            'preco': preco_path,
            'benchmark': benchmark_path,
            'volume': volume_path
        }
    
    def _gerar_grafico_preco(self, df: pd.DataFrame, caminho: str, codigo: str) -> None:
        """
        Gera gráfico de preço com médias móveis.
        
        Args:
            df: DataFrame com dados
            caminho: Caminho para salvar o gráfico
            codigo: Código do FII para título
        """
        plt.figure(figsize=(12, 6))
        
        # Preço
        plt.plot(df.index, df['fechamento'], label='Fechamento', color='blue')
        
        # Médias móveis
        if len(df) >= 50:
            mm50 = df['fechamento'].rolling(window=50).mean()
            plt.plot(df.index, mm50, label='MM 50', color='orange', linestyle='--')
        
        if len(df) >= 200:
            mm200 = df['fechamento'].rolling(window=200).mean()
            plt.plot(df.index, mm200, label='MM 200', color='red', linestyle='--')
        
        plt.title(f'Histórico de Preço - {codigo}')
        plt.xlabel('Data')
        plt.ylabel('Preço (R$)')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        
        plt.savefig(caminho)
        plt.close()
    
    def _gerar_grafico_benchmark(self, df_fii: pd.DataFrame, df_benchmark: pd.DataFrame,
                               caminho: str, codigo: str, benchmark: str) -> None:
        """
        Gera gráfico comparativo entre FII e benchmark.
        
        Args:
            df_fii: DataFrame do FII
            df_benchmark: DataFrame do benchmark
            caminho: Caminho para salvar o gráfico
            codigo: Código do FII
            benchmark: Código do benchmark
        """
        plt.figure(figsize=(12, 6))
        
        # Alinha as datas
        datas_comuns = df_fii.index.intersection(df_benchmark.index)
        
        if len(datas_comuns) > 0:
            df_fii_comum = df_fii.loc[datas_comuns]
            df_benchmark_comum = df_benchmark.loc[datas_comuns]
            
            # Normaliza para base 100
            df_fii_norm = df_fii_comum['fechamento'] / df_fii_comum['fechamento'].iloc[0] * 100
            df_bench_norm = df_benchmark_comum['fechamento'] / df_benchmark_comum['fechamento'].iloc[0] * 100
            
            plt.plot(datas_comuns, df_fii_norm, label=codigo, color='blue')
            plt.plot(datas_comuns, df_bench_norm, label=benchmark, color='green')
            
            plt.title(f'Desempenho Comparativo: {codigo} vs {benchmark} (Base 100)')
            plt.xlabel('Data')
            plt.ylabel('Desempenho (%)')
            plt.legend()
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            
            plt.savefig(caminho)
        
        plt.close()
    
    def _gerar_grafico_volume(self, df: pd.DataFrame, caminho: str, codigo: str) -> None:
        """
        Gera gráfico de volume de negociação.
        
        Args:
            df: DataFrame com dados
            caminho: Caminho para salvar o gráfico
            codigo: Código do FII para título
        """
        plt.figure(figsize=(12, 4))
        
        plt.bar(df.index, df['volume'], color='darkblue', alpha=0.7)
        
        plt.title(f'Volume de Negociação - {codigo}')
        plt.xlabel('Data')
        plt.ylabel('Volume (R$)')
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        
        plt.savefig(caminho)
        plt.close()
    
    def _gerar_html_relatorio(self, caminho: str, codigo: str, analise: Dict, 
                            graficos: Dict, data_inicio: str, data_fim: str,
                            benchmark: Optional[str] = None) -> None:
        """
        Gera o relatório em formato HTML.
        
        Args:
            caminho: Caminho para salvar o relatório
            codigo: Código do FII
            analise: Dicionário com resultados da análise
            graficos: Dicionário com caminhos para os gráficos
            data_inicio: Data inicial
            data_fim: Data final
            benchmark: Código do benchmark (opcional)
        """
        # Template HTML básico
        html = f"""
        <!DOCTYPE html>
        <html lang="pt-br">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Relatório de Desempenho - {codigo}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ text-align: center; margin-bottom: 30px; }}
                .summary {{ margin-bottom: 30px; }}
                .metrics {{ display: flex; flex-wrap: wrap; }}
                .metric {{ width: 30%; margin: 1%; padding: 10px; background-color: #f5f5f5; }}
                .charts {{ margin-top: 30px; }}
                .chart {{ margin-bottom: 30px; text-align: center; }}
                .chart img {{ max-width: 100%; }}
                table {{ width: 100%; border-collapse: collapse; }}
                th, td {{ padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }}
                th {{ background-color: #f2f2f2; }}
                .positive {{ color: green; }}
                .negative {{ color: red; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Relatório de Desempenho - {codigo}</h1>
                <p>Período: {data_inicio} a {data_fim}</p>
                <p>Gerado em: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}</p>
            </div>
            
            <div class="summary">
                <h2>Resumo de Desempenho</h2>
                <table>
                    <tr>
                        <th>Métrica</th>
                        <th>Valor</th>
                    </tr>
                    <tr>
                        <td>Retorno no Período</td>
                        <td class="{self._get_color_class(analise['retorno_periodo'])}">{analise['retorno_periodo']:.2f}%</td>
                    </tr>
                    <tr>
                        <td>Retorno Anualizado</td>
                        <td class="{self._get_color_class(analise['retorno_anualizado'])}">{analise['retorno_anualizado']:.2f}%</td>
                    </tr>
                    <tr>
                        <td>Volatilidade Anualizada</td>
                        <td>{analise['volatilidade']:.2f}%</td>
                    </tr>
                    <tr>
                        <td>Preço Máximo</td>
                        <td>R$ {analise['preco_maximo']:.2f} ({analise['data_maximo']})</td>
                    </tr>
                    <tr>
                        <td>Preço Mínimo</td>
                        <td>R$ {analise['preco_minimo']:.2f} ({analise['data_minimo']})</td>
                    </tr>
                    <tr>
                        <td>Tendência Atual</td>
                        <td>{analise['tendencia']}</td>
                    </tr>
                </table>
        """
        
        # Adiciona seção de benchmark se disponível
        if benchmark and 'benchmark' in analise and analise['benchmark']:
            b_stats = analise['benchmark']
            html += f"""
                <h2>Comparação com {benchmark}</h2>
                <table>
                    <tr>
                        <th>Métrica</th>
                        <th>Valor</th>
                    </tr>
                    <tr>
                        <td>Retorno do {benchmark} no Período</td>
                        <td class="{self._get_color_class(b_stats.get('retorno_benchmark', 0))}">{b_stats.get('retorno_benchmark', 0):.2f}%</td>
                    </tr>
                    <tr>
                        <td>Retorno Relativo</td>
                        <td class="{self._get_color_class(b_stats.get('retorno_relativo', 0))}">{b_stats.get('retorno_relativo', 0):.2f}%</td>
                    </tr>
                    <tr>
                        <td>Correlação</td>
                        <td>{b_stats.get('correlacao', 0):.2f}</td>
                    </tr>
                    <tr>
                        <td>Performance</td>
                        <td class="{self._get_color_class(b_stats.get('retorno_relativo', 0))}">
                            {"Superou" if b_stats.get('outperformance', False) else "Ficou abaixo do"} benchmark
                        </td>
                    </tr>
                </table>
            """
        
        # Adiciona gráficos
        html += """
            </div>
            
            <div class="charts">
                <h2>Análise Gráfica</h2>
        """
        
        if 'preco' in graficos and graficos['preco']:
            html += f"""
                <div class="chart">
                    <h3>Histórico de Preços</h3>
                    <img src="{os.path.relpath(graficos['preco'], os.path.dirname(caminho))}" alt="Gráfico de Preços">
                </div>
            """
        
        if 'benchmark' in graficos and graficos['benchmark']:
            html += f"""
                <div class="chart">
                    <h3>Comparação com Benchmark</h3>
                    <img src="{os.path.relpath(graficos['benchmark'], os.path.dirname(caminho))}" alt="Comparação com Benchmark">
                </div>
            """
        
        if 'volume' in graficos and graficos['volume']:
            html += f"""
                <div class="chart">
                    <h3>Volume de Negociação</h3>
                    <img src="{os.path.relpath(graficos['volume'], os.path.dirname(caminho))}" alt="Volume de Negociação">
                </div>
            """
        
        # Fecha o HTML
        html += """
            </div>
        </body>
        </html>
        """
        
        # Salva o arquivo HTML
        with open(caminho, 'w', encoding='utf-8') as f:
            f.write(html)
    
    def _get_color_class(self, valor: float) -> str:
        """
        Retorna a classe CSS baseada no valor (positivo ou negativo).
        
        Args:
            valor: Valor a ser avaliado
            
        Returns:
            Nome da classe CSS
        """
        if valor > 0:
            return "positive"
        elif valor < 0:
            return "negative"
        else:
            return ""
    
    def fechar(self) -> None:
        """
        Fecha conexões dos gerenciadores.
        """
        if hasattr(self, 'cotacoes_manager') and self.cotacoes_manager:
            self.cotacoes_manager.fechar_conexao()
            
        if hasattr(self, 'eventos_manager') and self.eventos_manager:
            self.eventos_manager.fechar_conexao()
```

##### 2.2 Integrar com a Interface CLI

```python
# Em main.py, adicionar o novo subparser
# ...
parser_relatorio = subparsers.add_parser('relatorio', 
                                       help='Gera relatório de desempenho de FIIs')
parser_relatorio.add_argument('--codigo', type=str, required=True,
                            help='Código do FII para análise')
parser_relatorio.add_argument('--inicio', type=str, required=True,
                            help='Data inicial (YYYY-MM-DD)')
parser_relatorio.add_argument('--fim', type=str, required=True,
                            help='Data final (YYYY-MM-DD)')
parser_relatorio.add_argument('--benchmark', type=str, 
                            help='Código do FII ou índice para comparação')
# ...

# Em main.py, adicionar a função de manipulação
def gerar_relatorio(args, logger) -> None:
    """
    Gera relatório de desempenho para um FII.
    
    Args:
        args: Argumentos da linha de comando
        logger: Logger para registro de eventos
    """
    imprimir_titulo(f"Relatório de Desempenho - {args.codigo.upper()}")
    
    try:
        from fii_utils.relatorio_desempenho import RelatorioDesempenhoManager
        
        # Instanciar o gerenciador
        relatorio_manager = RelatorioDesempenhoManager(args.db)
        
        try:
            # Gerar o relatório
            caminho_relatorio = relatorio_manager.gerar_relatorio(
                args.codigo,
                args.inicio,
                args.fim,
                args.benchmark
            )
            
            imprimir_sucesso(f"Relatório gerado com sucesso: {caminho_relatorio}")
            
            # Tentar abrir o relatório se possível
            import platform
            import subprocess
            
            try:
                if platform.system() == 'Darwin':  # macOS
                    subprocess.call(['open', caminho_relatorio])
                elif platform.system() == 'Windows':
                    subprocess.call(['start', caminho_relatorio], shell=True)
                elif platform.system() == 'Linux':
                    subprocess.call(['xdg-open', caminho_relatorio])
            except:
                imprimir_item("Nota", "Para visualizar o relatório, abra o arquivo manualmente")
                
        except Exception as e:
            imprimir_erro(f"Erro ao gerar relatório: {e}")
            logger.error(f"Erro ao gerar relatório: {e}")
            
        finally:
            # Fechar gerenciador
            relatorio_manager.fechar()
            
    except ImportError as e:
        imprimir_erro(f"Erro ao importar módulo: {e}")
        imprimir_aviso("Verifique se o matplotlib está instalado: pip install matplotlib")
        logger.error(f"Erro de importação: {e}")

# Em main.py, adicionar ao dispatcher
# ...
elif args.operacao == 'relatorio':
    gerar_relatorio(args, logger)
# ...
```

##### 2.3 Atualizar o README

Adicione documentação da nova funcionalidade ao README:

```markdown
### Geração de Relatórios de Desempenho

O sistema agora suporta a geração de relatórios detalhados de desempenho dos FIIs:

```bash
# Gerar relatório de desempenho para um FII
python main.py relatorio --codigo HGRE11 --inicio 2022-01-01 --fim 2022-12-31

# Gerar relatório com comparação a um benchmark
python main.py relatorio --codigo HGRE11 --inicio 2022-01-01 --fim 2022-12-31 --benchmark KNRI11
```

Os relatórios incluem:
- Métricas de desempenho (retorno no período, retorno anualizado, volatilidade)
- Preços máximos e mínimos com datas
- Análise de tendência baseada em médias móveis
- Comparação com benchmark (se especificado)
- Gráficos de preço, volume e desempenho comparativo
```

#### 3. Testes

##### 3.1 Teste Básico de Funcionalidade

Teste básico para verificar a funcionalidade do relatório:

```python
from fii_utils.relatorio_desempenho import RelatorioDesempenhoManager

# Instanciar o gerenciador
relatorio_manager = RelatorioDesempenhoManager()

try:
    # Teste com um FII conhecido
    caminho = relatorio_manager.gerar_relatorio(
        "KNRI11", 
        "2022-01-01", 
        "2022-12-31"
    )
    
    print(f"Relatório gerado: {caminho}")
    
finally:
    relatorio_manager.fechar()
```

### Exemplo 2: Adicionando um Endpoint de API Web

Neste exemplo, vamos adicionar uma API web simples para o sistema, permitindo acesso remoto às informações.

#### 1. Definição e Escopo

**Objetivo**: Criar uma API REST simples para consulta de cotações e informações sobre FIIs.

**Componentes necessários**:
- Servidor web usando Flask
- Endpoints para consulta de cotações, FIIs disponíveis e eventos
- Interface com os gerenciadores existentes

#### 2. Implementação

##### 2.1 Instalar Dependências

```bash
pip install flask flask-cors
```

##### 2.2 Criar o Módulo da API

```python
# fii_utils/api_server.py
from flask import Flask, jsonify, request
from flask_cors import CORS
import os
import logging
from typing import Dict, List, Any, Optional

from fii_utils.logging_manager import get_logger
from fii_utils.config_manager import get_config_manager
from db_managers.cotacoes import CotacoesManager
from db_managers.arquivos import ArquivosProcessadosManager
from db_managers.eventos import EventosCorporativosManager

class ApiServer:
    """
    Servidor API REST para o Sistema de Análise de FIIs.
    Fornece endpoints para acesso às informações do banco de dados.
    """
    
    def __init__(self, arquivo_db: str = 'fundos_imobiliarios.db', host: str = '0.0.0.0', port: int = 5000):
        self.arquivo_db = arquivo_db
        self.host = host
        self.port = port
        self.logger = get_logger('FIIAPI')
        self.config = get_config_manager()
        
        # Inicializa o servidor Flask
        self.app = Flask(__name__)
        CORS(self.app)  # Habilita CORS para permitir chamadas de outros domínios
        
        # Desativa o logger padrão do Flask
        log = logging.getLogger('werkzeug')
        log.setLevel(logging.ERROR)
        
        # Gerenciadores de banco de dados
        self.cotacoes_manager = CotacoesManager(arquivo_db)
        self.eventos_manager = EventosCorporativosManager(arquivo_db)
        self.arquivos_manager = ArquivosProcessadosManager(arquivo_db)
        
        # Registra os endpoints
        self._registrar_endpoints()
    
    def _registrar_endpoints(self) -> None:
        """
        Registra os endpoints da API.
        """
        # Endpoint de status
        @self.app.route('/api/status', methods=['GET'])
        def get_status():
            return jsonify({
                'status': 'online',
                'version': '1.0.0'
            })
        
        # Endpoint para listar FIIs disponíveis
        @self.app.route('/api/fiis', methods=['GET'])
        def get_fiis():
            try:
                if not self.cotacoes_manager.conn:
                    self.cotacoes_manager.conectar()
                    
                fiis = self.cotacoes_manager.listar_fiis()
                return jsonify({
                    'success': True,
                    'data': fiis
                })
            except Exception as e:
                self.logger.error(f"Erro ao listar FIIs: {e}")
                return jsonify({
                    'success': False,
                    'error': str(e)
                }), 500
        
        # Endpoint para obter cotações
        @self.app.route('/api/cotacoes/<codigo>', methods=['GET'])
        def get_cotacoes(codigo):
            try:
                data_inicio = request.args.get('inicio', None)
                data_fim = request.args.get('fim', None)
                
                if not data_inicio or not data_fim:
                    return jsonify({
                        'success': False,
                        'error': 'Os parâmetros "inicio" e "fim" são obrigatórios'
                    }), 400
                
                if not self.cotacoes_manager.conn:
                    self.cotacoes_manager.conectar()
                
                # Consulta as cotações
                self.cotacoes_manager.cursor.execute('''
                SELECT data, abertura, maxima, minima, fechamento, volume, negocios, quantidade
                FROM cotacoes
                WHERE codigo = ? AND data BETWEEN ? AND ?
                ORDER BY data
                ''', (codigo.upper(), data_inicio, data_fim))
                
                rows = self.cotacoes_manager.cursor.fetchall()
                
                # Converte para lista de dicionários
                result = []
                for row in rows:
                    result.append({
                        'data': row[0],
                        'abertura': row[1],
                        'maxima': row[2],
                        'minima': row[3],
                        'fechamento': row[4],
                        'volume': row[5],
                        'negocios': row[6],
                        'quantidade': row[7]
                    })
                
                return jsonify({
                    'success': True,
                    'codigo': codigo.upper(),
                    'data': result
                })
            except Exception as e:
                self.logger.error(f"Erro ao obter cotações para {codigo}: {e}")
                return jsonify({
                    'success': False,
                    'error': str(e)
                }), 500
        
        # Endpoint para obter eventos corporativos
        @self.app.route('/api/eventos', methods=['GET'])
        def get_eventos():
            try:
                codigo = request.args.get('codigo', None)
                
                if not self.eventos_manager.conn:
                    self.eventos_manager.conectar()
                
                if codigo:
                    eventos = self.eventos_manager.listar_eventos(codigo.upper())
                else:
                    eventos = self.eventos_manager.listar_eventos()
                
                return jsonify({
                    'success': True,
                    'data': eventos
                })
            except Exception as e:
                self.logger.error(f"Erro ao obter eventos: {e}")
                return jsonify({
                    'success': False,
                    'error': str(e)
                }), 500
        
        # Endpoint para obter estatísticas do banco
        @self.app.route('/api/stats', methods=['GET'])
        def get_stats():
            try:
                if not self.cotacoes_manager.conn:
                    self.cotacoes_manager.conectar()
                
                if not self.arquivos_manager.conn:
                    self.arquivos_manager.conectar()
                
                # Estatísticas de cotações
                stats = self.cotacoes_manager.obter_estatisticas()
                
                # Arquivos processados
                arquivos = self.arquivos_manager.listar_arquivos_processados()
                
                # Agrupar por tipo
                arquivos_por_tipo = {}
                for arquivo in arquivos:
                    tipo = arquivo['tipo']
                    if tipo not in arquivos_por_tipo:
                        arquivos_por_tipo[tipo] = {'count': 0, 'registros': 0}
                    
                    arquivos_por_tipo[tipo]['count'] += 1
                    arquivos_por_tipo[tipo]['registros'] += arquivo['registros_adicionados']
                
                return jsonify({
                    'success': True,
                    'cotacoes': stats,
                    'arquivos': {
                        'total': len(arquivos),
                        'por_tipo': arquivos_por_tipo
                    }
                })
            except Exception as e:
                self.logger.error(f"Erro ao obter estatísticas: {e}")
                return jsonify({
                    'success': False,
                    'error': str(e)
                }), 500
        
        # Endpoint para documentação da API
        @self.app.route('/api/docs', methods=['GET'])
        def get_docs():
            return jsonify({
                'endpoints': [
                    {
                        'path': '/api/status',
                        'method': 'GET',
                        'description': 'Retorna o status da API',
                        'params': []
                    },
                    {
                        'path': '/api/fiis',
                        'method': 'GET',
                        'description': 'Lista todos os FIIs disponíveis',
                        'params': []
                    },
                    {
                        'path': '/api/cotacoes/<codigo>',
                        'method': 'GET',
                        'description': 'Retorna cotações de um FII específico',
                        'params': [
                            {'name': 'inicio', 'type': 'string', 'format': 'YYYY-MM-DD', 'required': True},
                            {'name': 'fim', 'type': 'string', 'format': 'YYYY-MM-DD', 'required': True}
                        ]
                    },
                    {
                        'path': '/api/eventos',
                        'method': 'GET',
                        'description': 'Retorna eventos corporativos',
                        'params': [
                            {'name': 'codigo', 'type': 'string', 'required': False}
                        ]
                    },
                    {
                        'path': '/api/stats',
                        'method': 'GET',
                        'description': 'Retorna estatísticas do banco de dados',
                        'params': []
                    }
                ]
            })
    
    def iniciar(self) -> None:
        """
        Inicia o servidor API.
        """
        self.logger.info(f"Iniciando servidor API em {self.host}:{self.port}")
        
        try:
            # Conectar aos gerenciadores
            self.cotacoes_manager.conectar()
            self.eventos_manager.conectar()
            self.arquivos_manager.conectar()
            
            # Iniciar o servidor
            self.app.run(host=self.host, port=self.port)
            
        except KeyboardInterrupt:
            self.logger.info("Servidor API interrompido pelo usuário")
            
        except Exception as e:
            self.logger.error(f"Erro ao iniciar servidor API: {e}")
            
        finally:
            self.fechar()
    
    def fechar(self) -> None:
        """
        Fecha as conexões dos gerenciadores.
        """
        self.logger.info("Fechando conexões...")
        
        if hasattr(self, 'cotacoes_manager') and self.cotacoes_manager:
            self.cotacoes_manager.fechar_conexao()
            
        if hasattr(self, 'eventos_manager') and self.eventos_manager:
            self.eventos_manager.fechar_conexao()
            
        if hasattr(self, 'arquivos_manager') and self.arquivos_manager:
            self.arquivos_manager.fechar_conexao()
        
        self.logger.info("Servidor API finalizado")
```

##### 2.3 Implementar o Script para Iniciar o Servidor

```python
# scripts/api_server.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Script para iniciar um servidor API REST para o Sistema de Análise de FIIs.
"""

import os
import sys
import argparse

# Ajusta o path para importar os módulos do pacote
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from fii_utils.logging_manager import get_logger
from fii_utils.api_server import ApiServer
from fii_utils.cli_utils import imprimir_titulo, imprimir_item, imprimir_erro

def main():
    """
    Função principal para iniciar o servidor API.
    """
    # Configura o parser de argumentos
    parser = argparse.ArgumentParser(description='Inicia um servidor API REST para o Sistema de Análise de FIIs.')
    parser.add_argument('--db', type=str, default='fundos_imobiliarios.db',
                       help='Nome do arquivo de banco de dados (padrão: fundos_imobiliarios.db)')
    parser.add_argument('--host', type=str, default='0.0.0.0',
                       help='Host para o servidor (padrão: 0.0.0.0)')
    parser.add_argument('--port', type=int, default=5000,
                       help='Porta para o servidor (padrão: 5000)')
    
    args = parser.parse_args()
    
    # Configura o logger
    logger = get_logger('FIIApiServer')
    
    # Verifica se o banco de dados existe
    if not os.path.exists(args.db):
        logger.error(f"Banco de dados {args.db} não encontrado")
        imprimir_erro(f"Banco de dados {args.db} não encontrado")
        sys.exit(1)
    
    # Imprime informações do servidor
    imprimir_titulo("API REST para Sistema de Análise de FIIs")
    imprimir_item("Banco de dados", args.db)
    imprimir_item("Host", args.host)
    imprimir_item("Porta", args.port)
    
    # Inicializa e inicia o servidor
    server = ApiServer(args.db, args.host, args.port)
    
    try:
        # Inicia o servidor (bloqueante)
        server.iniciar()
        
    except KeyboardInterrupt:
        logger.info("Servidor interrompido pelo usuário")
        print("\nServidor interrompido pelo usuário")
        
    except Exception as e:
        logger.error(f"Erro ao iniciar servidor: {e}")
        imprimir_erro(f"Erro ao iniciar servidor: {e}")
        
    finally:
        # Garante que as conexões são fechadas
        server.fechar()

if __name__ == "__main__":
    main()
```

##### 2.4 Integrar com a Interface CLI Principal

```python
# Em main.py, adicionar o novo subparser
# ...
parser_api = subparsers.add_parser('api', 
                                 help='Inicia um servidor API REST')
parser_api.add_argument('--host', type=str, default='0.0.0.0',
                      help='Host para o servidor (padrão: 0.0.0.0)')
parser_api.add_argument('--port', type=int, default=5000,
                      help='Porta para o servidor (padrão: 5000)')
# ...

# Em main.py, adicionar a função de manipulação
def iniciar_api(args, logger) -> None:
    """
    Inicia o servidor API REST.
    
    Args:
        args: Argumentos da linha de comando
        logger: Logger para registro de eventos
    """
    imprimir_titulo("API REST para Sistema de Análise de FIIs")
    
    try:
        from fii_utils.api_server import ApiServer
        
        imprimir_item("Host", args.host)
        imprimir_item("Porta", args.port)
        
        # Inicializa o servidor
        server = ApiServer(args.db, args.host, args.port)
        
        print("Servidor API iniciado. Pressione Ctrl+C para interromper.")
        
        # Inicia o servidor (bloqueante)
        server.iniciar()
        
    except ImportError as e:
        imprimir_erro(f"Erro ao importar módulo: {e}")
        imprimir_aviso("Verifique se o Flask está instalado: pip install flask flask-cors")
        logger.error(f"Erro de importação: {e}")
        
    except Exception as e:
        imprimir_erro(f"Erro ao iniciar servidor API: {e}")
        logger.error(f"Erro ao iniciar servidor API: {e}")

# Em main.py, adicionar ao dispatcher
# ...
elif args.operacao == 'api':
    iniciar_api(args, logger)
# ...
```

##### 2.5 Atualizar o README

Adicione documentação da nova funcionalidade ao README:

```markdown
### API REST

O sistema agora inclui um servidor API REST para acesso remoto aos dados:

```bash
# Iniciar o servidor API na porta padrão (5000)
python main.py api

# Especificar host e porta
python main.py api --host localhost --port 8000
```

Endpoints disponíveis:
- `/api/status` - Verifica o status da API
- `/api/fiis` - Lista todos os FIIs disponíveis
- `/api/cotacoes/<codigo>?inicio=YYYY-MM-DD&fim=YYYY-MM-DD` - Retorna cotações de um FII
- `/api/eventos?codigo=XPTO11` - Retorna eventos corporativos (filtro opcional)
- `/api/stats` - Estatísticas do banco de dados
- `/api/docs` - Documentação da API

Para usar a API, é necessário instalar dependências adicionais:
```bash
pip install flask flask-cors
```
```

## Checklist para Novas Funcionalidades

Ao implementar novas funcionalidades, verifique os seguintes aspectos:

### 1. Planejamento e Design
- [ ] A funcionalidade tem um propósito claro e bem definido
- [ ] Foram identificados todos os componentes existentes afetados
- [ ] Foi criado um esboço ou diagrama da solução
- [ ] Foram consideradas alternativas de implementação

### 2. Implementação
- [ ] O código segue as convenções de nomenclatura do projeto
- [ ] Todas as classes e métodos possuem docstrings adequadas
- [ ] O código está bem estruturado e modular
- [ ] Foram usados os padrões de design apropriados
- [ ] O tratamento de erros é robusto e adequado
- [ ] O código não contém hardcoding de valores (usa ConfigManager)
- [ ] O código é eficiente para grandes volumes de dados

### 3. Integração
- [ ] A funcionalidade está corretamente integrada com os componentes existentes
- [ ] Não há duplicação desnecessária de código
- [ ] A interface da funcionalidade é consistente com o resto do sistema
- [ ] Há separação clara de responsabilidades

### 4. Interface de Usuário
- [ ] A CLI está clara e intuitiva
- [ ] A ajuda dos comandos é adequada e informativa
- [ ] O feedback ao usuário é claro e útil
- [ ] Há tratamento para erros de entrada do usuário

### 5. Testes
- [ ] O comportamento básico foi testado
- [ ] Casos de borda foram considerados e testados
- [ ] Condições de erro foram testadas
- [ ] Foram testados casos com volumes de dados reais

### 6. Documentação
- [ ] O README foi atualizado (se aplicável)
- [ ] A documentação interna é adequada
- [ ] Foi criada documentação para desenvolvedores (se necessário)
- [ ] Os exemplos de uso são claros e úteis

### 7. Performance
- [ ] A implementação é eficiente para o caso de uso
- [ ] Não há problemas de memória para grandes conjuntos de dados
- [ ] As operações de banco de dados são otimizadas
- [ ] Foram realizadas medições de performance (se aplicável)

### 8. Segurança
- [ ] Não há exposição de dados sensíveis
- [ ] As consultas SQL são parametrizadas
- [ ] Existe validação adequada de entrada

## Conclusão

A adição de novas funcionalidades ao Sistema de Análise de FIIs deve seguir um processo estruturado, desde o planejamento até a implementação e documentação. Este documento forneceu diretrizes e exemplos práticos para ajudar os desenvolvedores a estender o sistema de forma consistente e eficiente.

Lembre-se sempre de:
1. Entender a arquitetura existente antes de adicionar novos componentes
2. Manter a consistência com os padrões e convenções do projeto
3. Implementar de forma incremental, testando cada etapa
4. Documentar adequadamente as novas funcionalidades
5. Considerar o impacto da nova funcionalidade na performance geral do sistema

Seguindo estas diretrizes, você contribuirá para um sistema mais robusto, extensível e fácil de manter.
